//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : RandomSelector.cpp
//  @ Date : 22/07/2008
//  @ Author : 
//
//
#include <vector>
#include "Selector.h"
#include "RandomSelector.h"

//extern RandomGen *randomgen;

RandomSelector::RandomSelector() {
	
}

RandomSelector::RandomSelector(std::string name, CentralClock *pc) : Selector(name, pc)
{
	randgen = new RandomGen();
}

RandomSelector::~RandomSelector() 
{
	delete randgen;
}


int RandomSelector::GetRandomIndex(std::vector<float> *perVec)
{
	int index=0;
	float i=0.0;
	float incr=0.0;
	float sum=0.0;
	float randomvalue=randgen->GetRand01();

	std::vector<float>::iterator iter;
	
	for(iter=perVec->begin(); iter!=perVec->end(); iter++)
		sum+=(*iter);

	if(sum!=1.0)
		for(iter=perVec->begin(); iter!=perVec->end(); iter++)
			(*iter)=(*iter)/sum;

	for(iter=perVec->begin(); iter!=perVec->end(); iter++)
	{
		incr=(*iter);
		if(randomvalue>=i && randomvalue<i+(*iter)) 
		{
			if(element[index]->selector==NULL)
			{
				if(element[index]->lastEvent==NULL)
				{
					perVec->erase(iter);
					if(perVec->empty()==1)
						return(-1);
					else
						return index=GetRandomIndex(perVec);
				}
				else
					return index;
			}
			else
				return index;
		}
		else
			i=i+incr;
		index+=1;
	}

	if(index>=perVec->size())
		index=-1;

	return index;
}

std::string RandomSelector::retrieveSignal() {

	//printf("\n\n RandomSelector::retrieveSignal \n");
	
	int theRandom;
	std::vector<float> perVecCopy=percentageVec;
	
	std::string theEl;

	for(int i=0;i<element.size();i++) 
	{
		if(pc->GetTime()-element[i]->readTime>element[i]->frequency)
		{
			//element[i]->readTime=pc->GetTime();
			element[i]->ready=true;
		}
		else 
			element[i]->ready=false;
	}

	for(int i=0;i<element.size();i++) 
	{
		if((theRandom=GetRandomIndex(&perVecCopy))!=-1)
		{	
			if ( element[i]->ready)
			{				
				if(element[theRandom]->selector==NULL)
				{	
					if(element[theRandom]->lastEvent->behaviour!="") 
					{
						//printf("\n\n Queue %d not empty \n\n", theRandom);
					
						std::string beh=element[theRandom]->lastEvent->behaviour;
						element[theRandom]->lastEvent->behaviour="";
						element[theRandom]->lastEvent->time=-1;
						element[theRandom]->readTime=pc->GetTime();
						return beh;
					}
				}
				else 
				{
					//printf("Scheduler %d     theRandom %d\n",i, theRandom);
					std::string beh=element[theRandom]->selector->retrieveSignal();
					if (beh.length() != 0 )
					{
						element[theRandom]->readTime=pc->GetTime();
						return beh;
					}
					else
					{
						std::vector<float>::iterator iter;
						for(iter=perVecCopy.begin();iter!=perVecCopy.end();iter++)
							if(perVecCopy[theRandom]==(*iter))
								break;
						perVecCopy.erase(iter);
					}
				}
			}
		}
	}
	return ""; // No signal
}

/*
int RandomSelector::GetRandomIndex(std::vector<float> *perVec)
{
	int index=0;
	float i=0.0;
	float incr=0.0;
	float sum=0.0;
	float randomvalue=randgen->GetRand01();

	std::vector<float>::iterator iter;
	
	for(iter=perVec->begin(); iter!=perVec->end(); iter++)
		sum+=(*iter);

	if(sum!=1.0)
		for(iter=perVec->begin(); iter!=perVec->end(); iter++)
			(*iter)=(*iter)/sum;

	for(iter=perVec->begin(); iter!=perVec->end(); iter++)
	{
		incr=(*iter);
		if(randomvalue>=i && randomvalue<i+(*iter)) 
		{
			if  ( element.at(index)->queue != 0  )
			{
				if(element.at(index)->queue->empty())
				{
					perVec->erase(iter);
					if(perVec->empty()==1)
						return(-1);
					else
						return index=GetRandomIndex(perVec);
				}
				else
					return index;
			}
			else
				return index;
		}
		else
			i=i+incr;
		index+=1;
	}

	if(index>=perVec->size())
		index=-1;

	return index;
}

std::string RandomSelector::retrieveSignal() {

	//printf("\n\n RandomSelector::retrieveSignal \n");
	
	int theRandom;
	std::vector<float> perVecCopy=percentageVec;
	
	std::string theEl;

	for ( int i=0; i<num_of_elements; i++ ) 
	{
		if ( pc->GetTime() - element[i]->readTime > element[i]->frequency )
		{
			element[i]->readTime=pc->GetTime();
			element[i]->ready=true;
		}
		else 
			element[i]->ready=false;
	}

	for ( int i=0; i<num_of_elements; i++ ) 
	{
		if((theRandom=GetRandomIndex(&perVecCopy))!=-1)
		{	
			if ( element[i]->ready)
			{				
				if  ( element.at(theRandom)->queue != 0  )
				{	
					if ( !element.at(theRandom)->queue->empty() ) 
					{
						//printf("\n\n Queue %d not empty \n\n", theRandom);
					
						std::string beh=element.at(theRandom)->queue->at(0).behaviour;
						element[theRandom]->queue->erase(element[theRandom]->queue->begin());
						return beh;
					}
				}
				else 
				{
					//printf("Scheduler %d     theRandom %d\n",i, theRandom);
					std::string beh=element.at(theRandom)->selector->retrieveSignal();
					if (beh.length() != 0 )
						return beh;
					else
					{
						std::vector<float>::iterator iter;
						for(iter=perVecCopy.begin();iter!=perVecCopy.end();iter++)
							if(perVecCopy[theRandom]==(*iter))
								break;
						perVecCopy.erase(iter);
					}
				}
			}
			
		}
			
	}
	return ""; // No signal
}
*/