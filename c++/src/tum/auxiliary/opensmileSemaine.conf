
;;;;; all the components we require are listed here:
[componentInstances:cComponentManager]
 // this line configures the default data memory:
instance[dataMemory].type=cDataMemory
;instance[waveIn].type=cWaveSource
instance[liveIn].type=cPortaudioSource
;instance[resamp].type=cSpeexResample
;instance[resamp].type=cLibSamplerate
;instance[pps].type=cSpeexPreprocess
instance[fr1].type=cFramer
 ; framer with larger framesize for better pitch!
instance[fr2].type=cFramer
instance[pe2].type=cVectorPreemphasis
instance[w1].type=cWindower
instance[w2].type=cWindower
instance[fft1].type=cTransformFFT
;instance[fft1].threadId=1
instance[fftmp1].type=cFFTmagphase
;instance[fftmp1z].type=cVecGlMean
instance[fft2].type=cTransformFFT
;instance[fft2].threadId=0
instance[fftmp2].type=cFFTmagphase
;instance[fftmp2z].type=cVecGlMean
instance[mspec].type=cMelspec
instance[mspecASR].type=cMelspec

;instance[mspecz].type=cVecGlMean
instance[mfcc].type=cMfcc
instance[mfccASR].type=cMfcc

;instance[mfccSel].type=cDataSelector
instance[mfccz].type=cVecGlMean
instance[deltaM1].type=cDeltaRegression
;instance[mfcczD].type=cVecGlMean
instance[accM1].type=cDeltaRegression
;instance[mfcczA].type=cVecGlMean
instance[mzcr].type=cMZcr
instance[intens].type=cIntensity
instance[lpcE].type=cLpc
instance[lspE].type=cLsp

instance[bowProducerAro].type=cBowProducer
instance[bowProducerVal].type=cBowProducer

;;; --- test
instance[frV].type=cFramer
instance[frV2].type=cFramer
instance[frV2w].type=cWindower
instance[enV].type=cEnergy
instance[fftV].type=cTransformFFT
instance[fftmV].type=cFFTmagphase
;instance[acfV].type=cAcf
;instance[cepV].type=cAcf
;instance[pitchV].type=cPitchACF
instance[mspecV].type=cMelspec
;instance[mfccV].type=cMfcc
;instance[mspecVz].type=cVecGlMean
instance[lpc].type=cLpc
instance[lsp].type=cLsp
instance[vad].type=cVadV1
;instance[voiceLearn].type=cSpeechLearn
instance[speakerID].type=cSemaineSpeakerID1
;;; end test ---
;instance[acf].type=cAcf
;instance[cepstrum].type=cAcf
;instance[pitchACF].type=cPitchACF

instance[acf2].type=cAcf
instance[cepstrum2].type=cAcf
instance[pitchACF2].type=cPitchACF
instance[pitchDirection].type=cPitchDirection

; required only for turn detector, replaced by vad now
;instance[energy].type=cEnergy

instance[energy2].type=cEnergy
instance[energyF].type=cEnergy
instance[spectral].type=cSpectral
instance[lld].type=cContourSmoother
instance[delta1].type=cDeltaRegression
;instance[delta2].type=cDeltaRegression
instance[functL1].type=cFunctionals

instance[ftSelector].type=cDataSelector
instance[ftSender].type=cActiveMqSink
;instance[voiceRecv].type=cActiveMqSource

instance[emmaSender].type=cSemaineEmmaSender
instance[turn].type=cTurnDetector

;instance[aroSel].type=cDataSelector
instance[aroc].type=cLibsvmLiveSink
instance[arocLing].type=cLibsvmLiveSink
;instance[aroc].threadId=-1
instance[valc].type=cLibsvmLiveSink
instance[valcLing].type=cLibsvmLiveSink
;instance[aroc].threadId=-1
instance[power].type=cLibsvmLiveSink
instance[intensity].type=cLibsvmLiveSink
instance[expectation].type=cLibsvmLiveSink

instance[interest].type=cLibsvmLiveSink
instance[gender].type=cLibsvmLiveSink
;instance[arffsinkDbg].type=cArffSink
;instance[arffsink].type=cArffSink
;instance[lsvmsink].type=cLibsvmSink

instance[kwj].type=cTumkwsjSink
instance[turnOutp].type=cWaveSinkCut
;instance[dbg].type=cDatadumpSink
;instance[pr].type=cDatadumpSink
printLevelStats=4
nThreads=1

;;; test area
;instance[frV].type=cFramer
;instance[frV2].type=cFramer
;instance[enV].type=cEnergy
;instance[fftV].type=cTransformFFT
;instance[fftmV].type=cFFTmagphase
;instance[acfV].type=cAcf
;instance[cepV].type=cCepstrum
;instance[lpc].type=cLpc
;instance[lsp].type=cLsp
;instance[vad].type=cVadV1

[frV:cFramer]
reader.dmLevel=wave
writer.dmLevel=frV
;buffersize_sec=2.0
frameSize = 0.010
frameStep = 0.010

[frV2:cFramer]
reader.dmLevel=wave
writer.dmLevel=frV2
;buffersize_sec=2.0
frameSize = 0.032
frameStep = 0.010

[frV2w:cWindower]
reader.dmLevel=frV2
writer.dmLevel=frV2w
winFunc = ham
gain = 1.0

[enV:cEnergy]
reader.dmLevel=frV2w
writer.dmLevel=enV
nameAppend=energy
rms=1
log=1


[fftV:cTransformFFT]
reader.dmLevel=frV2w
writer.dmLevel=fftV

[fftmV:cFFTmagphase]
reader.dmLevel=fftV
writer.dmLevel=fftmV

[acfV:cAcf]
reader.dmLevel=fftmV
writer.dmLevel=acfV

[cepV:cAcf]
reader.dmLevel=fftmV
writer.dmLevel=cepV
cepstrum=1

[pitchV:cPitchACF]
  ; the pitchACF component must ALWAYS read from acf AND cepstrum in the given order!
reader.dmLevel=acfV;cepV
writer.dmLevel=f0raw
processArrayFields=0
F0=0
;F0raw=1
; note: when voice prob = 0, the processing hangs... TODO: why is this so?
voiceProb=1
HNR=0
F0env=0
voiceQual=0

[lpc:cLpc]
reader.dmLevel=frV
saveRefCoeff=0
writer.dmLevel=lpc
p=10

[mspecV:cMelspec]
reader.dmLevel=fftmV
writer.dmLevel=mspecV
htkcompatible = 0
usePower = 0
nBands = 14
lofreq = 50
hifreq = 4000

[mfccV:cMfcc]
reader.dmLevel=mspecV
writer.dmLevel=mfccV
;writer.levelconf.noHang=2
firstMfcc = 8
lastMfcc =  16
cepLifter = 22
htkcompatible = 1


[mspecVz:cVecGlMean]
reader.dmLevel=mspecV
writer.dmLevel=mspecVz
;htkcompatible = 1
fixedBuffer=10.0
updateMethod=fix
invertTurn=1
turnOnlyUpdate=0
;initFile=atk/cepmean




[lsp:cLsp]
reader.dmLevel=lpc
writer.dmLevel=lsp

[vad:cVadV1]
;reader.dmLevel=lsp;f0raw;enV
reader.dmLevel=mspecV;lsp;enV
writer.dmLevel=vad11
writer.levelconf.noHang=1
debug=\cm[vaddebug{0}:1=debug vad]
threshold=\cm[threshold{-13}:VAD threshold]
disableDynamicVAD=\cm[disableDynamicVAD{0}:disable dynamic threshold vad, instead use energy based vad only, the energy threshold can be set via the 'threshold' option]
;threshold=\cm[threshold{-13.0}:VAD energy threshold, minimum energy for dynamic vad, can be very small, it is used only as a backup; real threshold if disableDynamicVAD is set, in that case you should set the threshold to approx.]

[voiceLearn:cSpeechLearn]
;reader.dmLevel=lsp;f0raw;enV
;reader.dmLevel=mfccV;vad11
reader.dmLevel=mfccz1;mfccz1de;mfccz1dede;vad11
writer.dmLevel=vad1
writer.levelconf.noHang=1
debug=\cm[sldebug{0}:1=debug speech learner]
 ; 5 seconds training phase (5 for speech , 5 for noise)
trainDur = 300
 ; vad decay factor during vad smoothing
a0 = 0.05
a1 = 0.2

[speakerID:cSemaineSpeakerID1]
;reader.dmLevel=lsp;f0raw;enV
;reader.dmLevel=mfccV;vad11
;reader.dmLevel=mfccz1;mfccz1de;mfccz1dede;vad11
reader.dmLevel=mfcc1_1-12;mfcc1de;mfcc1dede;vad11
writer.dmLevel=vad1
writer.levelconf.noHang=1
debug=0
;\cm[sldebug{0}:1=debug speech learner]
 ; 6 seconds (600) training phase before using model for classification (6 for speech , 6 for noise)
 ; set this to 0 if you load an initialisation model
trainDur = \cm[trainDur{0}:train duration for speech learner VAD]
 ; vad decay factor during vad smoothing (a0 is attack, a1 is decay of voice)
a0 = 0.05
a1 = 0.2
;;; you can use these lines to load a predefined noise/speech model (and to save it at the end)
initNoiseModel=../auxiliary/sil.model.nocms
initSpeechModel=../auxiliary/voice.model.nocms
;initNoiseModel=../auxiliary/sil.model
;initSpeechModel=../auxiliary/voice.model
;; save model at the end::
;saveSpeechModel=model.speech.out
;saveNoiseModel=model.noise.out
;;; -1 as weight indicates that no online re-training should be performed
;;; numbers > 0 indicate the initial weight in 1/100 seconds (i.e. 1000) corresponds to a model equivalent to 10 seconds of speech
speechModelWeight=800
noiseModelWeight=400
 ; (agentBlockTime - speechModelWeight) / 100  = time in seconds to wait, before being able to interrupt the agent
agentBlockTime = 1600
maxTrainTime = 6000
;speechModelWeight=1000
;; for noise model weights the same parameters exist, just replace speech by noise
 ; set this to 1 to never detect a user turn while the agent is speaking
alwaysRejectAgent=\cm[alwaysRejectAgent{0}:set this to 1 to never detect a user turn while the agent is speaking]
ruleVadOnly=\cm[ruleVadOnly{0}:use ONLY rule based VAD, do NOT use NN models trained on-the-fly or loaded from file]

[pr:cDatadumpSink]
filename=lsp.dat
reader.dmLevel=mspecV;vad1


;;;;; semaine system specific config:

[semaine:semaineCfg]
semaine.amqSink[TumFeatureExtractor] = ftSender
semaine.topicW[TumFeatureExtractor] = semaine.data.analysis.features.voice
;semaine.amqSource[TumFeatureExtractor] = voiceRecv
;semaine.topicR[TumFeatureExtractor] = semaine.data.synthesis.lowlevel.audio,semaine.data.state.context
semaine.topicR[TumFeatureExtractor] = semaine.callback.output.audio
semaine.topicEmma[TumFeatureExtractor] = semaine.data.state.user.emma
semaine.emmaSender[TumFeatureExtractor] = emmaSender
semaine.callbackRecv[TumFeatureExtractor] = speakerID

[emmaSender:cSemaineEmmaSender]
dummy = 1

[turnOutp:cWaveSinkCut]
reader.dmLevel = frames

;;;;;;;;;;;;;;;;; below the config sections for the components start ;;;;;;;;;


  // --- pre-processing ---

[liveIn:cPortaudioSource]
writer.dmLevel=wave
; audio buffersize must be > then buffersize of framer to avoid 100% cpu hog
;audioBuffersize = 2500
audioBuffersize_sec = 0.32
buffersize_sec=1.5
channels=\cm[channels{1}:number of recording channels for live audio]
;sampleRate=16000
sampleRate=\cm[samplerate{48000}: sample-rate for live audio recording]
listDevices=\cm[listdevices{0}: value 1 = list available portaudio audio devices]
device=\cm[device{-1}: set portaudio audio device, -1 = default device]
monoMixdown=1

;[resamp:cSpeexResample]
;reader.dmLevel=wave
;writer.dmLevel=waveRS
;targetRate=16000
;blocksize=0.1

[resamp:cLibSamplerate]
reader.dmLevel=wave0
writer.dmLevel=wave
targetRate=16000
buffersize_sec=3.0
algo=lin
blocksizeR=4096
;blocksize=0.1


[pps:cSpeexPreprocess]
reader.dmLevel=wave
writer.dmLevel=wavePP
enableVAD=0
enableDenoise=1
blocksize_sec=0.02

[fr1:cFramer]
reader.dmLevel=wave
writer.dmLevel=frames
buffersize_sec=2.0
frameSize = 0.0250
frameStep = 0.010

[fr2:cFramer]
reader.dmLevel=wave
writer.dmLevel=frames2
frameSize = 0.040
frameStep = 0.010

[w2:cWindower]
reader.dmLevel=frames2
writer.dmLevel=winframe2
winFunc = ham
gain = 1.0


[pe2:cVectorPreemphasis]
reader.dmLevel=frames
writer.dmLevel=framespe
k=0.97
buffersize=1

[w1:cWindower]
reader.dmLevel=framespe
writer.dmLevel=winframe
winFunc = ham
gain = 1.0

  // ---- LLD -----

[fft1:cTransformFFT]
reader.dmLevel=winframe
writer.dmLevel=fftc

[fftmp1:cFFTmagphase]
reader.dmLevel=fftc
writer.dmLevel=fftmag

[fftmp1z:cVecGlMean]
reader.dmLevel=fftmag0
writer.dmLevel=fftmag
fixedBuffer=10.0
; this component should receive its turn start/end messages not from the turn detector, but from the semaineSpeakerID1 component!
turnOnlyUpdate=1
updateMethod=fix
invertTurn=1

[fft2:cTransformFFT]
reader.dmLevel=winframe2
writer.dmLevel=fftc2

[fftmp2:cFFTmagphase]
reader.dmLevel=fftc2
writer.dmLevel=fftmag2

[fftmp2z:cVecGlMean]
reader.dmLevel=fftmag02
writer.dmLevel=fftmag2
fixedBuffer=10.0
turnOnlyUpdate=1
updateMethod=fix
invertTurn=1


[mspec:cMelspec]
reader.dmLevel=fftmag
writer.dmLevel=mspec1
htkcompatible = 1
usePower = 1
nBands = 26
lofreq = 0
hifreq = 8000

[mfcc:cMfcc]
reader.dmLevel=mspec1
writer.dmLevel=mfcc1
;writer.levelconf.noHang=2
firstMfcc = 1
lastMfcc =  16
cepLifter = 22
htkcompatible = 1

[mspecASR:cMelspec]
reader.dmLevel=fftmag
writer.dmLevel=mspec1asr
htkcompatible = 1
usePower = 0
nBands = 26
lofreq = 0
hifreq = 8000

[mfccASR:cMfcc]
reader.dmLevel=mspec1asr
writer.dmLevel=mfcc1_1-12
;writer.levelconf.noHang=2
firstMfcc = 0
lastMfcc =  12
cepLifter = 22
htkcompatible = 1


[acf:cAcf]
reader.dmLevel=fftmag
writer.dmLevel=acf

[cepstrum:cAcf]
reader.dmLevel=fftmag
writer.dmLevel=cepstrum
cepstrum=1

[pitchACF:cPitchACF]
  ; the pitchACF component must ALWAYS read from acf AND cepstrum in the given order!
reader.dmLevel=acf;cepstrum
writer.dmLevel=pitch
processArrayFields=0
F0=1
voiceProb=1
HNR=0
F0env=1
voiceQual=0

[acf2:cAcf]
reader.dmLevel=fftmag2
writer.dmLevel=acf2

[cepstrum2:cAcf]
reader.dmLevel=fftmag2
writer.dmLevel=cepstrum2
cepstrum=1

[pitchACF2:cPitchACF]
  ; the pitchACF component must ALWAYS read from acf AND cepstrum in the given order!
reader.dmLevel=acf2;cepstrum2
writer.dmLevel=pitch2
processArrayFields=0
F0=1
voiceProb=1
HNR=0
F0env=1
voiceQual=0

[pitchDirection:cPitchDirection]
reader.dmLevel=pitch2;intens
writer.dmLevel=pitchDirection
directionMsgRecp=semaineEmmaSender

[energy:cEnergy]
reader.dmLevel=winframe
writer.dmLevel=energy
nameAppend=energy
rms=1
log=1

[energy2:cEnergy]
reader.dmLevel=winframe2
writer.dmLevel=energy2
nameAppend=energy
rms=1
log=1


[energyF:cEnergy]
reader.dmLevel=winframe
writer.dmLevel=energyF
nameAppend=energy
rms=0
log=1

[lpcE:cLpc]
reader.dmLevel=framespe
writer.dmLevel=lpcE
p=8

[lspE:cLsp]
reader.dmLevel=lpcE
writer.dmLevel=lspE

[intens:cIntensity]
reader.dmLevel=frames
writer.dmLevel=intens
intensity=1
loudness =1

[mzcr:cMZcr]
reader.dmLevel=frames
writer.dmLevel=mzcr
zcr=1
amax=0
mcr=1
maxmin=0

[spectral:cSpectral]
reader.dmLevel=fftmag
writer.dmLevel=spectral
bands[0]=0-250
bands[1]=0-650
bands[2]=250-650
bands[3]=1000-4000
bands[4]=50-160
rollOff[0] = 0.25
rollOff[1] = 0.50
rollOff[2] = 0.75
rollOff[3] = 0.90
entropy = 0

[lld:cContourSmoother]
reader.dmLevel=energyF;mfcc1;mzcr;pitch2;spectral;intens;lspE;mspec1
writer.dmLevel=lld
writer.levelconf.nT=36000
;writer.levelconf.noHang=2
writer.levelconf.isRb=1
  //        WARNING::::: TODOOOOO:   growDyn for ringbuffers, OR fixed size...//
;writer.levelconf.growDyn=1
;processArrayFields=0

[ftSelector:cDataSelector]
reader.dmLevel=pitch2;pitchDirection;energy2
writer.dmLevel=semaineLLD
writer.levelconf.noHang=2
selected = F0 ; voiceProb ; F0direction ; directionScore ; pcm_RMSenergy ; pcm_LOGenergy
newNames = F0frequency ; voiceProb ; pitchDirection ; pitchDirectionScore ; RMSenergy ; LOGenergy

[ftSender:cActiveMqSink]
reader.dmLevel=semaineLLD

  // ---- delta regression of LLD ----

[delta1:cDeltaRegression]
reader.dmLevel=lld
writer.dmLevel=lld_de
writer.levelconf.isRb=1
;writer.levelconf.growDyn=1
deltawin=2
blocksize=1

[delta2:cDeltaRegression]
reader.dmLevel=lld_de
writer.dmLevel=lld_dede
writer.levelconf.isRb=1
;writer.levelconf.growDyn=1
deltawin=2
blocksize=1


[functL1:cFunctionals]
reader.dmLevel=lld;lld_de
;lld_dede
writer.dmLevel=func
 ; frameSize and frameStep = 0 => functionals over complete input
 ; (NOTE: buffersize of lld and lld_de levels must be large enough!!)
frameMode = var
;frameSize=3.0
;frameStep=2.0
;functionalsEnabled=Extremes;Regression;Moments;Percentiles;Crossings;Peaks;Means
;Percentiles.percentile[0] = 0.95
;Percentiles.percentile[1] = 0.98
;Extremes.max = 0
;Extremes.min = 0
;Extremes.maxameandist=0
;Extremes.minameandist=0
;Extremes.amean=1
;Regression.qregc1 = 0
;Regression.qregc2 = 0
;Regression.qregc3 = 0
;Regression.qregerrA = 0
;Regression.qregerrQ = 0
;Regression.centroid = 0
;Regression.linregerrA = 0
;Moments.variance = 1

functionalsEnabled=Extremes;Regression;Moments;Percentiles;Times;Crossings;Peaks;Means
Extremes.maxameandist=0
Extremes.minameandist=0
Extremes.amean=1
Extremes.maxpos=1
Extremes.minpos=1
Extremes.max=0
Extremes.min=0
Extremes.range=0
Means.nzamean = 1
Means.amean=0
Regression.qregc1 = 0
Regression.qregc2 = 0
Regression.qregc3 = 0
Regression.qregerrA = 0
Regression.qregerrQ = 0
Regression.centroid = 1
Regression.linregerrA = 1
Regression.linregerrQ = 1
Regression.linregc1 = 1
Regression.linregc2 = 1
Moments.variance = 1
Moments.stddev = 1
Moments.skewness = 1
Moments.kurtosis = 1
Percentiles.quartiles = 1
Percentiles.iqr = 1
Percentiles.percentile = 0.05;0.95;0.98;0.03;0.97
Percentiles.pctlrange = 0-1
Times.duration = 1
Times.downleveltime25 = 1
Times.upleveltime25 = 0
Times.upleveltime75 = 1
Times.downleveltime75 = 0
Times.downleveltime50 = 0
Times.upleveltime50 = 0
Times.risetime = 1
Times.falltime = 1
Times.leftctime = 1
Times.rightctime = 1
Times.norm = turn
Crossings.amean = 0
Crossings.zcr = 0
Crossings.mcr = 1



[bowProducerAro:cBowProducer]
writer.dmLevel=bowA
count=0
kwList=models/emo/salarocLing/lingkwA.list

[bowProducerVal:cBowProducer]
writer.dmLevel=bowV
count=0
kwList=models/emo/salvalcLing/lingkwV.list

[turn:cTurnDetector]
;reader.dmLevel=energy
reader.dmLevel=vad1
readVad=1
writer.dmLevel=isTurn
writer.levelconf.noHang=1
msgInterval = 2.0
messageRecp = functL1,bowProducerAro,bowProducerVal
;eventRecp = fftmp1z,fftmp2z,mfccz,mfcczD,mfcczA,kwj,turnOutp
eventRecp = mfccz,mfcczD,mfcczA,kwj,turnOutp
statusRecp = emmaSender
;idx = 0
;autoThreshold = 0
;threshold = 0.0015
nPre=4
nPost=45
debug=\cm[turndebug{4}:set this to 1 to see turn/speaking debug messages]
maxTurnLength=8
maxTurnLengthGrace=10

[emo_enterface:cLibsvmLiveSink]
reader.dmLevel=func
model=scripts/modeltrain/built_models/ENTERFACE.fulls/allft.model
scale=scripts/modeltrain/built_models/ENTERFACE.fulls/allft.scale
classes=scripts/modeltrain/built_models/ENTERFACE.fulls/allft.classes
printResult=1
predictProbability=1

[gender:cLibsvmLiveSink]
reader.dmLevel=func
model=models/gender/allft.model.bin
scale=models/gender/allft.scale
classes=models/gender/allft.classes
fselection=models/gender/allft.fselection
resultRecp=emmaSender
resultMessageName=gender
printResult=1
predictProbability=1

;[aroSel:cDataSelector]
;reader.dmLevel=func
;writer.dmLevel=funcAro
;selFile=models/emo/salaroc/allft.fselection

[aroc:cLibsvmLiveSink]
reader.dmLevel=func
model=models/emo/salaroc/allft.model.bin
;model=models/emo/salaroc/allft.model
scale=models/emo/salaroc/allft.scale
fselection=models/emo/salaroc/allft.fselection
resultRecp=emmaSender
resultMessageName=acc_arousal
printResult=1
predictProbability=1

[valc:cLibsvmLiveSink]
reader.dmLevel=func
model=models/emo/salvalc/allft.model.bin
scale=models/emo/salvalc/allft.scale
fselection=models/emo/salvalc/allft.fselection
resultRecp=emmaSender
resultMessageName=acc_valence
printResult=1
predictProbability=1

[power:cLibsvmLiveSink]
reader.dmLevel=func
model=models/emo/power/allft.model.bin
scale=models/emo/power/allft.scale
fselection=models/emo/power/allft.fselection
resultRecp=emmaSender
resultMessageName=power
printResult=1
predictProbability=1

[intensity:cLibsvmLiveSink]
reader.dmLevel=func
model=models/emo/intensity/allft.model.bin
scale=models/emo/intensity/allft.scale
fselection=models/emo/intensity/allft.fselection
resultRecp=emmaSender
resultMessageName=intensity
printResult=1
predictProbability=1

[expectation:cLibsvmLiveSink]
reader.dmLevel=func
model=models/emo/expectation/allft.model.bin
scale=models/emo/expectation/allft.scale
fselection=models/emo/expectation/allft.fselection
resultRecp=emmaSender
resultMessageName=expectation
printResult=1
predictProbability=1


[arocLing:cLibsvmLiveSink]
reader.dmLevel=func;bowA
model=models/emo/salarocLing/allft.model.bin
scale=models/emo/salarocLing/allft.scale
fselection=models/emo/salarocLing/allft.fselection
resultRecp=emmaSender
resultMessageName=arousal
printResult=1
predictProbability=1

[valcLing:cLibsvmLiveSink]
reader.dmLevel=func;bowV
model=models/emo/salvalcLing/allft.model.bin
scale=models/emo/salvalcLing/allft.scale
fselection=models/emo/salvalcLing/allft.fselection
resultRecp=emmaSender
resultMessageName=valence
printResult=1
predictProbability=1

[interest:cLibsvmLiveSink]
reader.dmLevel=func
model=models/emo/interest/allft.model.bin
scale=models/emo/interest/allft.scale
classes=models/emo/interest/allft.classes
fselection=models/emo/interest/allft.fselection
resultRecp=emmaSender
resultMessageName=interest
printResult=1
predictProbability=1



[deltaM1:cDeltaRegression]
reader.dmLevel=mfcc1_1-12
writer.dmLevel=mfcc1de
buffersize_sec=2.0
;writer.levelconf.isRb=1
;writer.levelconf.growDyn=1
deltawin=2
blocksize=1

[accM1:cDeltaRegression]
reader.dmLevel=mfcc1de
writer.dmLevel=mfcc1dede
buffersize_sec=2.0
;writer.levelconf.isRb=1
;writer.levelconf.growDyn=1
deltawin=2
blocksize=1

[mspecz:cVecGlMean]
reader.dmLevel=mspec1
writer.dmLevel=mspec1z
;htkcompatible = 1
alpha=0.998
fixedBuffer=5.0
updateMethod=fix
invertTurn=1
;initFile=atk/cepmean

// select only MFCC 1-12 from level mfcc1
[mfccSel:cDataSelector]
reader.dmLevel=mfcc1
writer.dmLevel=mfcc1_1-12
selected=mfcc[1-12]
elementMode=0


[mfccz:cVecGlMean]
reader.dmLevel=mfcc1_1-12
writer.dmLevel=mfccz1
; buffersize of level mfccz1: (required for proper turn start processing of ASR)
buffersize_sec=15.0
;htkcompatible = 1
alpha=0.994
weight = 100.0
fixedBuffer=10.0
turnOnlyUpdate = 1
updateMethod=fix
resetOnTurn = 0

[mfcczD:cVecGlMean]
reader.dmLevel=mfcc1de
writer.dmLevel=mfccz1de
; buffersize of level mfccz1: (required for proper turn start processing of ASR)
buffersize_sec=15.0
;htkcompatible = 1
alpha=0.994
weight = 100.0
fixedBuffer=10.0
turnOnlyUpdate = 1
updateMethod=fix
resetOnTurn = 0

[mfcczA:cVecGlMean]
reader.dmLevel=mfcc1dede
writer.dmLevel=mfccz1dede
; buffersize of level mfccz1: (required for proper turn start processing of ASR)
buffersize_sec=15.0
;htkcompatible = 1
alpha=0.994
weight = 100.0
fixedBuffer=10.0
turnOnlyUpdate = 1
updateMethod=fix
resetOnTurn = 0


[kwj:cTumkwsjSink]
reader.dmLevel = mfccz1;mfcc1de;mfcc1dede
configfile = ../auxiliary/kws.cfg
logfile = .julius.log
 ; show julius debug messages: 1/0 yes/no
debug = 0
printResult = \cm[asrResult{1}:set to 0 to disable printing of keyword spotter result]
gprob = -4.0
;gprob = 0.1
kprob = -10.0
;kprob = -0.3
numphon = 39
resultRecp=emmaSender,bowProducerAro,bowProducerVal
wlenWeight = 0.0
;wlenWeight = 0.5
dynamicLm = 0
lmfile = ../auxiliary/keyword.weights
lmpenalty=-2.0

;[arffsinkDbg:cArffSink]
;reader.dmLevel=mfcc1_1-12
;filename=dbg.arff

[arffsink:cArffSink]
reader.dmLevel=func
number=0
filename=\cm[arffout(O){semaine_emo_features_live.arff}:name of WEKA Arff output file]
relation=\cm[corpus{SEMAINE_live_features}:corpus name, arff relation]
instanceName=\cm[instname(N){unlabelled}:name of arff instance]
class[0].name = emotion
class[0].type = \cm[classes{0}:all classes for arff file attribute]
target[0].all = \cm[classlabel(a){unknown}:instance class label]
append=0

[lsvmsink:cLibsvmSink]
reader.dmLevel=funcAro
filename=\cm[arffout(O){semaine_emo_features_live.lsvm}:name of WEKA Arff output file]
targetNumAll[0]=0

[dbg:cDatadumpSink]
reader.dmLevel = pitch
filename=dbg_pitch.dat

