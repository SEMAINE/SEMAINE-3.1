
;;;;; all the components we require are listed here:
[componentInstances:cComponentManager]
 // this line configures the default data memory:
instance[dataMemory].type=cDataMemory
;instance[waveIn].type=cWaveSource
instance[liveIn].type=cPortaudioSource
;instance[resamp].type=cSpeexResample
;instance[resamp].type=cLibSamplerate
;instance[pps].type=cSpeexPreprocess
instance[fr1].type=cFramer
 ; framer with larger framesize for better pitch!
instance[fr2].type=cFramer
instance[pe2].type=cVectorPreemphasis
instance[w1].type=cWindower
instance[w2].type=cWindower
instance[fft1].type=cTransformFFT
instance[fftmp1].type=cFFTmagphase
instance[fftmp1z].type=cVecGlMean
instance[fft2].type=cTransformFFT
instance[fftmp2].type=cFFTmagphase
instance[fftmp2z].type=cVecGlMean
instance[mspec].type=cMelspec
;instance[mspecz].type=cVecGlMean
instance[mfcc].type=cMfcc
instance[mfccz].type=cVecGlMean
instance[deltaM1].type=cDeltaRegression
instance[mfcczD].type=cVecGlMean
instance[accM1].type=cDeltaRegression
instance[mfcczA].type=cVecGlMean
instance[mzcr].type=cMZcr
;;; --- test
instance[frV].type=cFramer
instance[frV2].type=cFramer
instance[frV2w].type=cWindower
instance[enV].type=cEnergy
instance[fftV].type=cTransformFFT
instance[fftmV].type=cFFTmagphase
;instance[acfV].type=cAcf
;instance[cepV].type=cAcf
;instance[pitchV].type=cPitchACF
instance[mspecV].type=cMelspec
instance[mfccV].type=cMfcc
;instance[mspecVz].type=cVecGlMean
instance[lpc].type=cLpc
instance[lsp].type=cLsp
instance[vad].type=cVadV1
instance[voiceLearn].type=cSpeechLearn
;;; end test ---
instance[acf].type=cAcf
instance[cepstrum].type=cAcf
instance[pitchACF].type=cPitchACF
instance[acf2].type=cAcf
instance[cepstrum2].type=cAcf
instance[pitchACF2].type=cPitchACF

; required only for turn detector, replaced by vad now
;instance[energy].type=cEnergy

instance[energy2].type=cEnergy
instance[energyF].type=cEnergy
instance[spectral].type=cSpectral
instance[lld].type=cContourSmoother
instance[delta1].type=cDeltaRegression
instance[delta2].type=cDeltaRegression
instance[functL1].type=cFunctionals
instance[ftSelector].type=cDataSelector
instance[ftSender].type=cActiveMqSink
instance[voiceRecv].type=cActiveMqSource
instance[emmaSender].type=cSemaineEmmaSender
instance[turn].type=cTurnDetector
;instance[emo_enterface].type=cLibsvmLiveSink
;instance[gender].type=cLibsvmLiveSink
instance[aroc].type=cLibsvmLiveSink
;instance[aroc].threadId=-1
instance[valc].type=cLibsvmLiveSink
;instance[aroc].threadId=-1
instance[interest].type=cLibsvmLiveSink
instance[arffsink].type=cArffSink
instance[kwj].type=cTumkwsjSink
instance[turnOutp].type=cWaveSinkCut
;instance[dbg].type=cDatadumpSink
;instance[pr].type=cDatadumpSink
printLevelStats=4
nThreads=1

;;; test area
;instance[frV].type=cFramer
;instance[frV2].type=cFramer
;instance[enV].type=cEnergy
;instance[fftV].type=cTransformFFT
;instance[fftmV].type=cFFTmagphase
;instance[acfV].type=cAcf
;instance[cepV].type=cCepstrum
;instance[lpc].type=cLpc
;instance[lsp].type=cLsp
;instance[vad].type=cVadV1

[frV:cFramer]
reader.dmLevel=wave
writer.dmLevel=frV
;buffersize_sec=2.0
frameSize = 0.010
frameStep = 0.010

[frV2:cFramer]
reader.dmLevel=wave
writer.dmLevel=frV2
;buffersize_sec=2.0
frameSize = 0.032
frameStep = 0.010

[frV2w:cWindower]
reader.dmLevel=frV2
writer.dmLevel=frV2w
winFunc = ham
gain = 1.0

[enV:cEnergy]
reader.dmLevel=frV2w
writer.dmLevel=enV
nameAppend=energy
rms=1
log=1


[fftV:cTransformFFT]
reader.dmLevel=frV2w
writer.dmLevel=fftV

[fftmV:cFFTmagphase]
reader.dmLevel=fftV
writer.dmLevel=fftmV

[acfV:cAcf]
reader.dmLevel=fftmV
writer.dmLevel=acfV

[cepV:cAcf]
reader.dmLevel=fftmV
writer.dmLevel=cepV
cepstrum=1

[pitchV:cPitchACF]
  ; the pitchACF component must ALWAYS read from acf AND cepstrum in the given order!
reader.dmLevel=acfV;cepV
writer.dmLevel=f0raw
processArrayFields=0
F0=0
;F0raw=1
; note: when voice prob = 0, the processing hangs... TODO: why is this so?
voiceProb=1
HNR=0
F0env=0
voiceQual=0

[lpc:cLpc]
reader.dmLevel=frV
saveRefCoeff=0
writer.dmLevel=lpc
p=10

[mspecV:cMelspec]
reader.dmLevel=fftmV
writer.dmLevel=mspecV
htkcompatible = 0
usePower = 0
nBands = 14
lofreq = 50
hifreq = 4000

[mfccV:cMfcc]
reader.dmLevel=mspecV
writer.dmLevel=mfccV
;writer.levelconf.noHang=2
firstMfcc = 8
lastMfcc =  16
cepLifter = 22
htkcompatible = 1


[mspecVz:cVecGlMean]
reader.dmLevel=mspecV
writer.dmLevel=mspecVz
;htkcompatible = 1
fixedBuffer=10.0
updateMethod=fix
invertTurn=1
turnOnlyUpdate=0
;initFile=atk/cepmean




[lsp:cLsp]
reader.dmLevel=lpc
writer.dmLevel=lsp

[vad:cVadV1]
;reader.dmLevel=lsp;f0raw;enV
reader.dmLevel=mspecV;lsp;enV
writer.dmLevel=vad11
writer.levelconf.noHang=1
debug=\cm[vaddebug{0}:1=debug vad]

[voiceLearn:cSpeechLearn]
;reader.dmLevel=lsp;f0raw;enV
;reader.dmLevel=mfccV;vad11
reader.dmLevel=mfccz1;mfccz1de;mfccz1dede;vad11
writer.dmLevel=vad1
writer.levelconf.noHang=1
debug=\cm[sldebug{0}:1=debug speech learner]
 ; 5 seconds training phase (5 for speech , 5 for noise)
trainDur = 300
 ; vad decay factor during vad smoothing
a0 = 0.05
a1 = 0.2

[pr:cDatadumpSink]
filename=lsp.dat
reader.dmLevel=mspecV;vad1


;;;;; semaine system specific config:

[semaine:semaineCfg]
semaine.amqSink[TumFeatureExtractor] = ftSender
semaine.topicW[TumFeatureExtractor] = semaine.data.analysis.features.voice
semaine.amqSource[TumFeatureExtractor] = voiceRecv
semaine.topicR[TumFeatureExtractor] = semaine.data.synthesis.lowlevel.audio
semaine.topicEmma[TumFeatureExtractor] = semaine.data.state.user.emma
semaine.emmaSender[TumFeatureExtractor] = emmaSender

[emmaSender:cSemaineEmmaSender]
dummy = 1

[turnOutp:cWaveSinkCut]
reader.dmLevel = frames

;;;;;;;;;;;;;;;;; below the config sections for the components start ;;;;;;;;;


  // --- pre-processing ---

[liveIn:cPortaudioSource]
writer.dmLevel=wave
; audio buffersize must be > then buffersize of framer to avoid 100% cpu hog
;audioBuffersize = 2500
audioBuffersize_sec = 0.16
buffersize_sec=2.0
channels=1
;sampleRate=16000
sampleRate=\cm[samplerate{16000}: sample-rate for live audio recording]
listDevices=\cm[listdevices{0}: value 1 = list available portaudio audio devices]
device=\cm[device{-1}: set portaudio audio device, -1 = default device]
;monoMixdown=1

;[resamp:cSpeexResample]
;reader.dmLevel=wave
;writer.dmLevel=waveRS
;targetRate=16000
;blocksize=0.1

[resamp:cLibSamplerate]
reader.dmLevel=wave0
writer.dmLevel=wave
targetRate=16000
buffersize_sec=3.0
algo=lin
blocksizeR=4096
;blocksize=0.1


[pps:cSpeexPreprocess]
reader.dmLevel=wave
writer.dmLevel=wavePP
enableVAD=0
enableDenoise=1
blocksize_sec=0.02

[fr1:cFramer]
reader.dmLevel=wave
writer.dmLevel=frames
buffersize_sec=2.0
frameSize = 0.0250
frameStep = 0.010

[fr2:cFramer]
reader.dmLevel=wave
writer.dmLevel=frames2
frameSize = 0.040
frameStep = 0.010

[w2:cWindower]
reader.dmLevel=frames2
writer.dmLevel=winframe2
winFunc = ham
gain = 1.0


[pe2:cVectorPreemphasis]
reader.dmLevel=frames
writer.dmLevel=framespe
k=0.97
buffersize=1

[w1:cWindower]
reader.dmLevel=framespe
writer.dmLevel=winframe
winFunc = ham
gain = 1.0

  // ---- LLD -----

[fft1:cTransformFFT]
reader.dmLevel=winframe
writer.dmLevel=fftc

[fftmp1:cFFTmagphase]
reader.dmLevel=fftc
writer.dmLevel=fftmag0

[fftmp1z:cVecGlMean]
reader.dmLevel=fftmag0
writer.dmLevel=fftmag
fixedBuffer=10.0
turnOnlyUpdate=1
updateMethod=fix
invertTurn=1

[fft2:cTransformFFT]
reader.dmLevel=winframe2
writer.dmLevel=fftc2

[fftmp2:cFFTmagphase]
reader.dmLevel=fftc2
writer.dmLevel=fftmag02

[fftmp2z:cVecGlMean]
reader.dmLevel=fftmag02
writer.dmLevel=fftmag2
fixedBuffer=10.0
turnOnlyUpdate=1
updateMethod=fix
invertTurn=1


[mspec:cMelspec]
reader.dmLevel=fftmag
writer.dmLevel=mspec1
htkcompatible = 1
usePower = 0
nBands = 26
lofreq = 0
hifreq = 8000

[mfcc:cMfcc]
reader.dmLevel=mspec1
writer.dmLevel=mfcc1
;writer.levelconf.noHang=2
firstMfcc = 0
lastMfcc =  12
cepLifter = 22
htkcompatible = 1


[acf:cAcf]
reader.dmLevel=fftmag
writer.dmLevel=acf

[cepstrum:cAcf]
reader.dmLevel=fftmag
writer.dmLevel=cepstrum
cepstrum=1

[pitchACF:cPitchACF]
  ; the pitchACF component must ALWAYS read from acf AND cepstrum in the given order!
reader.dmLevel=acf;cepstrum
writer.dmLevel=pitch
processArrayFields=0
F0=1
voiceProb=1
HNR=0
F0env=1
voiceQual=0

[acf2:cAcf]
reader.dmLevel=fftmag2
writer.dmLevel=acf2

[cepstrum2:cAcf]
reader.dmLevel=fftmag2
writer.dmLevel=cepstrum2
cepstrum=1

[pitchACF2:cPitchACF]
  ; the pitchACF component must ALWAYS read from acf AND cepstrum in the given order!
reader.dmLevel=acf2;cepstrum2
writer.dmLevel=pitch2
processArrayFields=0
F0=1
voiceProb=1
HNR=0
F0env=1
voiceQual=0


[energy:cEnergy]
reader.dmLevel=winframe
writer.dmLevel=energy
nameAppend=energy
rms=1
log=1

[energy2:cEnergy]
reader.dmLevel=winframe2
writer.dmLevel=energy2
nameAppend=energy
rms=1
log=1


[energyF:cEnergy]
reader.dmLevel=winframe
writer.dmLevel=energyF
nameAppend=energy
rms=0
log=1

[mzcr:cMZcr]
reader.dmLevel=frames
writer.dmLevel=mzcr
zcr=1
amax=0
mcr=0
maxmin=0

[spectral:cSpectral]
reader.dmLevel=fftmag
writer.dmLevel=spectral
bands[0]=0-250
bands[1]=0-650
bands[2]=250-650
bands[3]=1000-4000
rollOff[0] = 0.25
rollOff[1] = 0.50
rollOff[2] = 0.75
rollOff[3] = 0.90
entropy = 0

[lld:cContourSmoother]
reader.dmLevel=energyF;mfcc1;mzcr;pitch;spectral
writer.dmLevel=lld
writer.levelconf.nT=10
;writer.levelconf.noHang=2
writer.levelconf.isRb=0
  //        WARNING::::: TODOOOOO:   growDyn for ringbuffers, OR fixed size...//
writer.levelconf.growDyn=1
;processArrayFields=0

[ftSelector:cDataSelector]
reader.dmLevel=pitch2;energy2
writer.dmLevel=semaineLLD
writer.levelconf.noHang=2
selected = F0 ; voiceProb ; pcm_RMSenergy ; pcm_LOGenergy
newNames = F0frequency ; voiceProb ; RMSenergy ; LOGenergy

[ftSender:cActiveMqSink]
reader.dmLevel=semaineLLD

[voiceRecv:cActiveMqSource]
writer.dmLevel=maryvoice

  // ---- delta regression of LLD ----

[delta1:cDeltaRegression]
reader.dmLevel=lld
writer.dmLevel=lld_de
writer.levelconf.isRb=0
writer.levelconf.growDyn=1
deltawin=2
blocksize=1

[delta2:cDeltaRegression]
reader.dmLevel=lld_de
writer.dmLevel=lld_dede
writer.levelconf.isRb=0
writer.levelconf.growDyn=1
deltawin=2
blocksize=1


[functL1:cFunctionals]
reader.dmLevel=lld;lld_de;lld_dede
writer.dmLevel=func
 ; frameSize and frameStep = 0 => functionals over complete input
 ; (NOTE: buffersize of lld and lld_de levels must be large enough!!)
frameMode = var
;frameSize=3.0
;frameStep=2.0
functionalsEnabled=Extremes;Regression;Moments;Percentiles;Crossings;Peaks;Means
Percentiles.percentile[0] = 0.95
Percentiles.percentile[1] = 0.98
Crossings.amean = 0
Crossings.zcr = 0
Crossings.mcr = 1
Means.nzamean = 0
Extremes.max = 0
Extremes.min = 0

;Extremes.maxameandist=0
;Extremes.minameandist=0
;Extremes.amean=1
;Regression.qregc1 = 0
;Regression.qregc2 = 0
;Regression.qregc3 = 0
;Regression.qregerrA = 0
;Regression.qregerrQ = 0
;Regression.centroid = 0
;Regression.linregerrA = 0
;Moments.variance = 1


[turn:cTurnDetector]
;reader.dmLevel=energy
reader.dmLevel=vad1
readVad=1
writer.dmLevel=isTurn
writer.levelconf.noHang=1
messageRecp = functL1
eventRecp = mfccz,mfcczD,mfcczA,kwj,turnOutp
statusRecp = emmaSender
;idx = 0
;autoThreshold = 0
;threshold = 0.0015
nPre=5
nPost=20

[emo_enterface:cLibsvmLiveSink]
reader.dmLevel=func
model=scripts/modeltrain/built_models/ENTERFACE.fulls/allft.model
scale=scripts/modeltrain/built_models/ENTERFACE.fulls/allft.scale
classes=scripts/modeltrain/built_models/ENTERFACE.fulls/allft.classes
printResult=1
predictProbability=1

[gender:cLibsvmLiveSink]
reader.dmLevel=func
model=scripts/modeltrain/built_models/gender_f01/allft.model
scale=scripts/modeltrain/built_models/gender_f01/allft.scale
classes=scripts/modeltrain/built_models/gender_f01/allft.classes
printResult=1
predictProbability=1

[aroc:cLibsvmLiveSink]
reader.dmLevel=func
model=models/emo/salaroc.lsvm.model
scale=models/emo/salaroc.lsvm.scale
resultRecp=emmaSender
resultMessageName=arousal
printResult=1
predictProbability=1

[valc:cLibsvmLiveSink]
reader.dmLevel=func
model=models/emo/salvalc.lsvm.model
scale=models/emo/salvalc.lsvm.scale
resultRecp=emmaSender
resultMessageName=valence
printResult=1
predictProbability=1

[interest:cLibsvmLiveSink]
reader.dmLevel=func
model=models/emo/avic.loi.model
scale=models/emo/avic.loi.scale
resultRecp=emmaSender
resultMessageName=interest
printResult=1
predictProbability=1



[deltaM1:cDeltaRegression]
reader.dmLevel=mfcc1
writer.dmLevel=mfcc1de
buffersize_sec=2.0
;writer.levelconf.isRb=1
;writer.levelconf.growDyn=1
deltawin=2
blocksize=1

[accM1:cDeltaRegression]
reader.dmLevel=mfcc1de
writer.dmLevel=mfcc1dede
buffersize_sec=2.0
;writer.levelconf.isRb=1
;writer.levelconf.growDyn=1
deltawin=2
blocksize=1

[mspecz:cVecGlMean]
reader.dmLevel=mspec1
writer.dmLevel=mspec1z
;htkcompatible = 1
alpha=0.998
fixedBuffer=5.0
updateMethod=fix
invertTurn=1
;initFile=atk/cepmean


[mfccz:cVecGlMean]
reader.dmLevel=mfcc1
writer.dmLevel=mfccz1
; buffersize of level mfccz1: (required for proper turn start processing of ASR)
buffersize_sec=5.0
;htkcompatible = 1
alpha=0.994
weight = 100.0
fixedBuffer=5.0
turnOnlyUpdate = 1
updateMethod=fix
resetOnTurn = 0

[mfcczD:cVecGlMean]
reader.dmLevel=mfcc1de
writer.dmLevel=mfccz1de
; buffersize of level mfccz1: (required for proper turn start processing of ASR)
buffersize_sec=5.0
;htkcompatible = 1
alpha=0.994
weight = 100.0
fixedBuffer=7.0
turnOnlyUpdate = 1
updateMethod=fix
resetOnTurn = 0

[mfcczA:cVecGlMean]
reader.dmLevel=mfcc1dede
writer.dmLevel=mfccz1dede
; buffersize of level mfccz1: (required for proper turn start processing of ASR)
buffersize_sec=5.0
;htkcompatible = 1
alpha=0.994
weight = 100.0
fixedBuffer=7.0
turnOnlyUpdate = 1
updateMethod=fix
resetOnTurn = 0


[kwj:cTumkwsjSink]
reader.dmLevel = mfccz1;mfccz1de;mfccz1dede
configfile = ../auxiliary/kws.cfg
logfile = .julius.log
 ; show julius debug messages: 1/0 yes/no
debug = 0
printResult = 1
gprob = -0.1
kprob = -0.3
numphon = 39
resultRecp=emmaSender
wlenWeight = 0.3

[arffsink:cArffSink]
;reader.dmLevel=spectral;energy;pitch;mfcc1;mzcr
reader.dmLevel=func
number=0
filename=\cm[arffout(O){output.arff}:name of WEKA Arff output file]
relation=\cm[corpus{ASRU_EMO_paper}:corpus name, arff relation]
instanceName=\cm[instname(N){unlabelled}:name of arff instance]
class[0].name = emotion
class[0].type = \cm[classes{0}:all classes for arff file attribute]
target[0].all = \cm[classlabel(a){unknown}:instance class label]
append=0

[dbg:cDatadumpSink]
reader.dmLevel = pitch
filename=dbg_pitch.dat

