
;;;;; all the components we require are listed here:
[componentInstances:cComponentManager]
 // this line configures the default data memory:
instance[dataMemory].type=cDataMemory
;instance[waveIn].type=cWaveSource
instance[liveIn].type=cPortaudioSource
instance[fr1].type=cFramer
 ; framer with larger framesize for better pitch!
instance[fr2].type=cFramer
instance[pe2].type=cVectorPreemphasis
instance[w1].type=cWindower
instance[w2].type=cWindower
instance[fft1].type=cTransformFFT
instance[fftmp1].type=cFFTmagphase
instance[fft2].type=cTransformFFT
instance[fftmp2].type=cFFTmagphase
instance[mspec].type=cMelspec
instance[mfcc].type=cMfcc
instance[mfccz].type=cVecGlMean
instance[deltaM1].type=cDeltaRegression
instance[accM1].type=cDeltaRegression
instance[mzcr].type=cMZcr
instance[acf].type=cAcf
instance[cepstrum].type=cAcf
instance[pitchACF].type=cPitchACF
instance[acf2].type=cAcf
instance[cepstrum2].type=cAcf
instance[pitchACF2].type=cPitchACF
instance[energy].type=cEnergy
instance[energy2].type=cEnergy
instance[energyF].type=cEnergy
instance[spectral].type=cSpectral
instance[lld].type=cContourSmoother
instance[delta1].type=cDeltaRegression
instance[delta2].type=cDeltaRegression
instance[functL1].type=cFunctionals
instance[ftSelector].type=cDataSelector
instance[ftSender].type=cActiveMqSink
instance[emmaSender].type=cSemaineEmmaSender
instance[turn].type=cTurnDetector
;instance[emo_enterface].type=cLibsvmLiveSink
;instance[gender].type=cLibsvmLiveSink
instance[aroc].type=cLibsvmLiveSink
;instance[aroc].threadId=-1
instance[valc].type=cLibsvmLiveSink
;instance[aroc].threadId=-1
instance[interest].type=cLibsvmLiveSink
;instance[arffsink].type=cArffSink
instance[kwj].type=cTumkwsjSink
;instance[turnOutp].type=cWaveSinkCut
;instance[dbg].type=cDatadumpSink
printLevelStats=2
nThreads=1

;;;;; semaine system specific config:

[semaine:semaineCfg]
semaine.amqSink[TumFeatureExtractor] = ftSender
semaine.topicW[TumFeatureExtractor] = semaine.data.analysis.features.voice
semaine.topicEmma[TumFeatureExtractor] = semaine.data.state.user.emma
semaine.emmaSender[TumFeatureExtractor] = emmaSender

[emmaSender:cSemaineEmmaSender]
dummy = 1

[turnOutp:cWaveSinkCut]
reader.dmLevel = frames

;;;;;;;;;;;;;;;;; below the config sections for the components start ;;;;;;;;;


  // --- pre-processing ---

[liveIn:cPortaudioSource]
writer.dmLevel=wave
buffersize=8000
channels=1
sampleRate=16000
;monoMixdown=1

[fr1:cFramer]
reader.dmLevel=wave
writer.dmLevel=frames
frameSize = 0.0250
frameStep = 0.010
buffersize = 1000

[fr2:cFramer]
reader.dmLevel=wave
writer.dmLevel=frames2
frameSize = 0.080
frameStep = 0.010
buffersize = 10

[w2:cWindower]
reader.dmLevel=frames2
writer.dmLevel=winframe2
winFunc = ham
gain = 1.0


[pe2:cVectorPreemphasis]
reader.dmLevel=frames
writer.dmLevel=framespe
k=0.97

[w1:cWindower]
reader.dmLevel=framespe
writer.dmLevel=winframe
winFunc = ham
gain = 1.0

  // ---- LLD -----

[fft1:cTransformFFT]
reader.dmLevel=winframe
writer.dmLevel=fftc

[fftmp1:cFFTmagphase]
reader.dmLevel=fftc
writer.dmLevel=fftmag

[fft2:cTransformFFT]
reader.dmLevel=winframe2
writer.dmLevel=fftc2

[fftmp2:cFFTmagphase]
reader.dmLevel=fftc2
writer.dmLevel=fftmag2


[mspec:cMelspec]
reader.dmLevel=fftmag
writer.dmLevel=mspec1
htkcompatible = 1
usePower = 0
nBands = 26
lofreq = 0
hifreq = 8000

[mfcc:cMfcc]
reader.dmLevel=mspec1
writer.dmLevel=mfcc1
;writer.levelconf.noHang=2
firstMfcc = 0
lastMfcc =  12
cepLifter = 22
htkcompatible = 1


[acf:cAcf]
reader.dmLevel=fftmag
writer.dmLevel=acf

[cepstrum:cAcf]
reader.dmLevel=fftmag
writer.dmLevel=cepstrum
cepstrum=1

[pitchACF:cPitchACF]
  ; the pitchACF component must ALWAYS read from acf AND cepstrum in the given order!
reader.dmLevel=acf;cepstrum
writer.dmLevel=pitch
processArrayFields=0
F0=1
voiceProb=1
HNR=0
F0env=1
voiceQual=0

[acf2:cAcf]
reader.dmLevel=fftmag2
writer.dmLevel=acf2

[cepstrum2:cAcf]
reader.dmLevel=fftmag2
writer.dmLevel=cepstrum2
cepstrum=1

[pitchACF2:cPitchACF]
  ; the pitchACF component must ALWAYS read from acf AND cepstrum in the given order!
reader.dmLevel=acf2;cepstrum2
writer.dmLevel=pitch2
processArrayFields=0
F0=1
voiceProb=1
HNR=0
F0env=1
voiceQual=0


[energy:cEnergy]
reader.dmLevel=winframe
writer.dmLevel=energy
nameAppend=energy
rms=1
log=1

[energy2:cEnergy]
reader.dmLevel=winframe2
writer.dmLevel=energy2
nameAppend=energy
rms=1
log=1


[energyF:cEnergy]
reader.dmLevel=winframe
writer.dmLevel=energyF
nameAppend=energy
rms=0
log=1

[mzcr:cMZcr]
reader.dmLevel=frames
writer.dmLevel=mzcr
zcr=1
amax=0
mcr=0
maxmin=0

[spectral:cSpectral]
reader.dmLevel=fftmag
writer.dmLevel=spectral
bands[0]=0-250
bands[1]=0-650
bands[2]=250-650
bands[3]=1000-4000
rollOff[0] = 0.25
rollOff[1] = 0.50
rollOff[2] = 0.75
rollOff[3] = 0.90


[lld:cContourSmoother]
reader.dmLevel=energyF;mfcc1;mzcr;pitch;spectral
writer.dmLevel=lld
writer.levelconf.nT=10
;writer.levelconf.noHang=2
writer.levelconf.isRb=0
  //        WARNING::::: TODOOOOO:   growDyn for ringbuffers, OR fixed size...//
writer.levelconf.growDyn=1
;processArrayFields=0

[ftSelector:cDataSelector]
reader.dmLevel=pitch2;energy2
writer.dmLevel=semaineLLD
selected = F0 ; voiceProb ; pcm_RMSenergy ; pcm_LOGenergy
newNames = F0frequency ; voiceProb ; RMSenergy ; LOGenergy

[ftSender:cActiveMqSink]
reader.dmLevel=semaineLLD


  // ---- delta regression of LLD ----

[delta1:cDeltaRegression]
reader.dmLevel=lld
writer.dmLevel=lld_de
writer.levelconf.isRb=0
writer.levelconf.growDyn=1
deltawin=2
blocksize=1

[delta2:cDeltaRegression]
reader.dmLevel=lld_de
writer.dmLevel=lld_dede
writer.levelconf.isRb=0
writer.levelconf.growDyn=1
deltawin=2
blocksize=1


[functL1:cFunctionals]
reader.dmLevel=lld;lld_de;lld_dede
writer.dmLevel=func
 ; frameSize and frameStep = 0 => functionals over complete input
 ; (NOTE: buffersize of lld and lld_de levels must be large enough!!)
frameMode = var
;frameSize=3.0
;frameStep=2.0
functionalsEnabled=Extremes;Regression;Moments;Percentiles;Crossings;Peaks;Means
Percentiles.percentile[0] = 0.95
Percentiles.percentile[1] = 0.98
Crossings.amean = 0
Crossings.zcr = 0
Crossings.mcr = 1
Means.nzamean = 0
Extremes.max = 0
Extremes.min = 0

;Extremes.maxameandist=0
;Extremes.minameandist=0
;Extremes.amean=1
;Regression.qregc1 = 0
;Regression.qregc2 = 0
;Regression.qregc3 = 0
;Regression.qregerrA = 0
;Regression.qregerrQ = 0
;Regression.centroid = 0
;Regression.linregerrA = 0
;Moments.variance = 1


[turn:cTurnDetector]
reader.dmLevel=energy
writer.dmLevel=isTurn
writer.levelconf.noHang=1
messageRecp = functL1
eventRecp = kwj,turnOutp
statusRecp = emmaSender
idx = 0
threshold = 0.002

[emo_enterface:cLibsvmLiveSink]
reader.dmLevel=func
model=scripts/modeltrain/built_models/ENTERFACE.fulls/allft.model
scale=scripts/modeltrain/built_models/ENTERFACE.fulls/allft.scale
classes=scripts/modeltrain/built_models/ENTERFACE.fulls/allft.classes
printResult=1
predictProbability=1

[gender:cLibsvmLiveSink]
reader.dmLevel=func
model=scripts/modeltrain/built_models/gender_f01/allft.model
scale=scripts/modeltrain/built_models/gender_f01/allft.scale
classes=scripts/modeltrain/built_models/gender_f01/allft.classes
printResult=1
predictProbability=1

[aroc:cLibsvmLiveSink]
reader.dmLevel=func
model=models/emo/salaroc.lsvm.model
scale=models/emo/salaroc.lsvm.scale
resultRecp=emmaSender
resultMessageName=arousal
printResult=1
predictProbability=1

[valc:cLibsvmLiveSink]
reader.dmLevel=func
model=models/emo/salvalc.lsvm.model
scale=models/emo/salvalc.lsvm.scale
resultRecp=emmaSender
resultMessageName=valence
printResult=1
predictProbability=1

[interest:cLibsvmLiveSink]
reader.dmLevel=func
model=models/emo/avic.loi.model
scale=models/emo/avic.loi.scale
resultRecp=emmaSender
resultMessageName=interest
printResult=1
predictProbability=1



[deltaM1:cDeltaRegression]
reader.dmLevel=mfccz1
writer.dmLevel=mfcc1de
;writer.levelconf.isRb=1
;writer.levelconf.growDyn=1
deltawin=2
blocksize=1

[accM1:cDeltaRegression]
reader.dmLevel=mfcc1de
writer.dmLevel=mfcc1dede
;writer.levelconf.isRb=1
;writer.levelconf.growDyn=1
deltawin=2
blocksize=1

[mfccz:cVecGlMean]
reader.dmLevel=mfcc1
writer.dmLevel=mfccz1
htkcompatible = 1
alpha=0.999
;initFile=atk/cepmean


[kwj:cTumkwsjSink]
 ; todo add d/a
reader.dmLevel = mfccz1;mfcc1de;mfcc1dede
configfile = ../aux/kws.cfg
logfile = .julius.log
printResult = 1
gprob = -0.1
kprob = 0.0
numkw = 344
resultRecp=emmaSender

[arffsink:cArffSink]
;reader.dmLevel=spectral;energy;pitch;mfcc1;mzcr
reader.dmLevel=func
number=0
filename=\cm[arffout(O){output.arff}:name of WEKA Arff output file]
relation=\cm[corpus{ASRU_EMO_paper}:corpus name, arff relation]
instanceName=\cm[instname(N){unlabelled}:name of arff instance]
class[0].name = emotion
class[0].type = \cm[classes{0}:all classes for arff file attribute]
target[0].all = \cm[classlabel(a){unknown}:instance class label]
append=0

[dbg:cDatadumpSink]
reader.dmLevel = pitch2
filename=dbg_pitch.dat

